import rclpy
from rclpy.node import Node
from control_msgs.msg import JointJog
from geometry_msgs.msg import TwistStamped
from sensor_msgs.msg import Joy
from rclpy.qos import QoSProfile
import can
from can import Message
import time


class Arm_Control(Node):

    def __init__(self):
        super().__init__('Arm_Control')
       
        self.drive_data = self.create_subscription(msg_type = Float32MultiArray, topic = drive_topic, qos_profile = rclpy.qos.qos_profile_system_default, callback= self.drivemsg)

        self.steer_data = self.create_subscription(msg_type = Float32MultiArray, topic = steer_topic, qos_profile = rclpy.qos.qos_profile_system_default, callback= self.steermsg)

        self.bus = can.interface.Bus(interface='socketcan', channel='vcan0', bitrate=500000)
        
        self.timer = self.create_timer(timer_period_sec = timer_period, callback = self.ros2can)




    def drivemsg(self, msg):
        
        self.drive_msg = msg

    def steermsg(self, msg):

        self.steer_msg = msg


    def ros2can(self):

        # Convert ROS messages to CAN messages
        drive_can_messages = self.drive_float32_can()
        steer_can_messages = self.steer_float32_can()

        # Publish CAN messages on the CAN bus
        self.can_publish(drive_can_messages)
        self.can_publish(steer_can_messages)

        

    def drive_float32_can(self):

        priority = 4  
        node_id = 0
        frame_id = 0x10   
            
        can_messages = []
            
        for i in range(6):
            arbitration_id = (priority << 24) | (frame_id << 8) | node_id
            velocity = self.drive_msg.data[i]
            
            # Convert the 32-bit float velocity to 4 bytes
            velocity_bytes = struct.pack('f', velocity)
            actuator_id_bytes = struct.pack('B', i)
            
            # Combine actuator_id and velocity into one 8-byte data
            data_msg = actuator_id_bytes + velocity_bytes
                
            # Create a CAN message
            can_msg = can.Message(arbitration_id=arbitration_id, data=data_msg)
            can_messages.append(can_msg)
            
        return can_messages
        

    def steer_float32_can(self):

        priority = 5
        node_id = 0
        frame_id = 0x11   
            
        can_messages = []
            
        for i in range(4):
            arbitration_id = (priority << 24) | (frame_id << 8) | node_id
            velocity = self.steer_msg.data[i]
            
            # Convert the 32-bit float velocity to 4 bytes
            velocity_bytes = struct.pack('f', velocity)
            actuator_id_bytes = struct.pack('B', (i + 6))
            
            # Combine actuator_id and velocity into one 8-byte data
            data_msg = actuator_id_bytes + velocity_bytes
                
            # Create a CAN message
            can_msg = can.Message(arbitration_id=arbitration_id, data=data_msg)
            can_messages.append(can_msg)

        return can_messages

    def can_publish(self, can_messages):

        for msg in can_messages:
            self.bus.send(msg)


        

    
    def can_recieve(self):

        pass
        